{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n/**\n * Gets the configured messages for Decidim. The configuration is passed from\n * the view to the JS within the layout template.\n *\n * @param {String | null} key The top-level key to fetch from the messages\n *   object or `null` to fetch all messages.\n * @returns {Object} The messages object\n */\nexport var getMessages = function getMessages() {\n  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var allMessages = window.Decidim.config.get(\"messages\");\n  if (key === null) {\n    return allMessages;\n  }\n  var messages = allMessages;\n  key.split(\".\").forEach(function (part) {\n    return messages = messages[part] || {};\n  });\n  return messages;\n};\n\n/**\n * Turns a deep messages object into a dictionary object with a single level and\n * the keys separated with a dot.\n *\n * @param {Object} messages The messages object\n * @param {String | null} prefix Prefix for the messages on recursive calls\n * @returns {Object} The converted dictionary object\n */\nexport var createDictionary = function createDictionary(messages) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var _final = {};\n  Object.keys(messages).forEach(function (key) {\n    if (_typeof(messages[key]) === \"object\") {\n      _final = _objectSpread(_objectSpread({}, _final), createDictionary(messages[key], \"\".concat(prefix).concat(key, \".\")));\n    } else if (key === \"\") {\n      _final[(prefix === null || prefix === void 0 ? void 0 : prefix.replace(/\\.$/, \"\")) || \"\"] = messages[key];\n    } else {\n      _final[\"\".concat(prefix).concat(key)] = messages[key];\n    }\n  });\n  return _final;\n};\n\n/**\n * Creates a dictionary object from the top-level messages object with the\n * provided key.\n *\n * @param {String | null} key The top-level message key to create the dictionary\n *   for\n * @returns {Object} The dictionary object\n */\nexport var getDictionary = function getDictionary(key) {\n  return createDictionary(getMessages(key));\n};","map":{"version":3,"names":["getMessages","key","arguments","length","undefined","allMessages","window","Decidim","config","get","messages","split","forEach","part","createDictionary","prefix","_final","Object","keys","_typeof","_objectSpread","concat","replace","getDictionary"],"sources":["/home/daniele/decidim_idra-main/app/packs/src/decidim/i18n.js"],"sourcesContent":["/**\n * Gets the configured messages for Decidim. The configuration is passed from\n * the view to the JS within the layout template.\n *\n * @param {String | null} key The top-level key to fetch from the messages\n *   object or `null` to fetch all messages.\n * @returns {Object} The messages object\n */\nexport const getMessages = (key = null) => {\n  const allMessages = window.Decidim.config.get(\"messages\");\n  if (key === null) {\n    return allMessages;\n  }\n  let messages = allMessages;\n  key.split(\".\").forEach((part) => (messages = messages[part] || {}));\n  return messages;\n};\n\n/**\n * Turns a deep messages object into a dictionary object with a single level and\n * the keys separated with a dot.\n *\n * @param {Object} messages The messages object\n * @param {String | null} prefix Prefix for the messages on recursive calls\n * @returns {Object} The converted dictionary object\n */\nexport const createDictionary = (messages, prefix = \"\") => {\n  let final = {};\n  Object.keys(messages).forEach((key) => {\n    if (typeof messages[key] === \"object\") {\n      final = { ...final, ...createDictionary(messages[key], `${prefix}${key}.`) };\n    } else if (key === \"\") {\n      final[prefix?.replace(/\\.$/, \"\") || \"\"] = messages[key];\n    } else {\n      final[`${prefix}${key}`] = messages[key];\n    }\n  });\n\n  return final;\n};\n\n/**\n * Creates a dictionary object from the top-level messages object with the\n * provided key.\n *\n * @param {String | null} key The top-level message key to create the dictionary\n *   for\n * @returns {Object} The dictionary object\n */\nexport const getDictionary = (key) => {\n  return createDictionary(getMessages(key));\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMA,WAAW,GAAG,SAAdA,WAAWA,CAAA,EAAmB;EAAA,IAAfC,GAAG,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EACpC,IAAMG,WAAW,GAAGC,MAAM,CAACC,OAAO,CAACC,MAAM,CAACC,GAAG,CAAC,UAAU,CAAC;EACzD,IAAIR,GAAG,KAAK,IAAI,EAAE;IAChB,OAAOI,WAAW;EACpB;EACA,IAAIK,QAAQ,GAAGL,WAAW;EAC1BJ,GAAG,CAACU,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,CAAC,UAACC,IAAI;IAAA,OAAMH,QAAQ,GAAGA,QAAQ,CAACG,IAAI,CAAC,IAAI,CAAC,CAAC;EAAA,CAAC,CAAC;EACnE,OAAOH,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMI,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIJ,QAAQ,EAAkB;EAAA,IAAhBK,MAAM,GAAAb,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EACpD,IAAIc,MAAK,GAAG,CAAC,CAAC;EACdC,MAAM,CAACC,IAAI,CAACR,QAAQ,CAAC,CAACE,OAAO,CAAC,UAACX,GAAG,EAAK;IACrC,IAAIkB,OAAA,CAAOT,QAAQ,CAACT,GAAG,CAAC,MAAK,QAAQ,EAAE;MACrCe,MAAK,GAAAI,aAAA,CAAAA,aAAA,KAAQJ,MAAK,GAAKF,gBAAgB,CAACJ,QAAQ,CAACT,GAAG,CAAC,KAAAoB,MAAA,CAAKN,MAAM,EAAAM,MAAA,CAAGpB,GAAG,OAAI,CAAE;IAC9E,CAAC,MAAM,IAAIA,GAAG,KAAK,EAAE,EAAE;MACrBe,MAAK,CAAC,CAAAD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEO,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,KAAI,EAAE,CAAC,GAAGZ,QAAQ,CAACT,GAAG,CAAC;IACzD,CAAC,MAAM;MACLe,MAAK,IAAAK,MAAA,CAAIN,MAAM,EAAAM,MAAA,CAAGpB,GAAG,EAAG,GAAGS,QAAQ,CAACT,GAAG,CAAC;IAC1C;EACF,CAAC,CAAC;EAEF,OAAOe,MAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMO,aAAa,GAAG,SAAhBA,aAAaA,CAAItB,GAAG,EAAK;EACpC,OAAOa,gBAAgB,CAACd,WAAW,CAACC,GAAG,CAAC,CAAC;AAC3C,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}
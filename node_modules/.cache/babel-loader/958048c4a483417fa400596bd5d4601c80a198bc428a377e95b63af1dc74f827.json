{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nvar parseMsoListStyles = function parseMsoListStyles(doc) {\n  var _doc$querySelector;\n  var style = (_doc$querySelector = doc.querySelector(\"style\")) === null || _doc$querySelector === void 0 ? void 0 : _doc$querySelector.textContent;\n  if (!style) {\n    return {};\n  }\n  var listStyles = {};\n  _toConsumableArray(style.matchAll(/@list\\s+(l\\d+:level\\d+)[\\s]+\\{([^}]+)\\}/g)).forEach(function (match) {\n    var styleDefs = {};\n    match[2].replace(/[\\s]+/g, \"\").split(\";\").forEach(function (styleDef) {\n      var _styleDef$split = styleDef.split(\":\"),\n        _styleDef$split2 = _slicedToArray(_styleDef$split, 2),\n        key = _styleDef$split2[0],\n        val = _styleDef$split2[1];\n      styleDefs[key] = val;\n    });\n    listStyles[match[1]] = styleDefs;\n  });\n  return listStyles;\n};\nvar detectMsoList = function detectMsoList(element) {\n  var currentStyle = element.getAttribute(\"style\");\n  if (!currentStyle) {\n    return {\n      type: null,\n      level: 1\n    };\n  }\n  var listStyleMatch = currentStyle.match(/mso-list:(l\\d+)\\s(level\\d+)/);\n  if (listStyleMatch) {\n    var _listStyleMatch = _slicedToArray(listStyleMatch, 3),\n      type = _listStyleMatch[1],\n      level = _listStyleMatch[2];\n    return {\n      type: type,\n      level: parseInt(level.match(/\\d/), 10)\n    };\n  }\n  return {\n    type: null,\n    level: 1\n  };\n};\nvar getMsoListStyle = function getMsoListStyle(type, level, styleDefs) {\n  if (type === null) {\n    return {};\n  }\n  var typeStyle = styleDefs[type] || {};\n  var levelStyle = styleDefs[\"\".concat(type, \":level\").concat(level)] || {};\n  return Object.assign(typeStyle, levelStyle);\n};\nvar converMsoListStyleToHtml = function converMsoListStyleToHtml(listStyle) {\n  var tag = \"ol\",\n    type = null;\n  switch (listStyle[\"mso-level-number-format\"]) {\n    case \"bullet\":\n      tag = \"ul\";\n      break;\n    case \"alpha-lower\":\n    case \"lower-alpha\":\n      type = \"a\";\n      break;\n    case \"alpha-upper\":\n    case \"upper-alpha\":\n      type = \"A\";\n      break;\n    case \"roman-lower\":\n    case \"lower-roman\":\n      type = \"i\";\n      break;\n    case \"roman-upper\":\n    case \"upper-roman\":\n      type = \"I\";\n      break;\n    default:\n      type = \"1\";\n      break;\n  }\n  return {\n    tag: tag,\n    type: type\n  };\n};\nexport var removeMsMetaSegments = function removeMsMetaSegments(html) {\n  return html.replace(/<!\\[if\\s+[^\\]]+\\]>((?!<!\\[endif\\])[\\s\\S])+<!\\[endif\\]>/g, \"\");\n};\n\n/**\n * Fixes issues pasting content from desktop version of Word. Replaces the flat\n * lists represented with `<p>` elements with actual list hierarchy based on the\n * data available in the HTML copied from desktop Word.\n *\n * See: https://github.com/ueberdosis/tiptap/issues/3756\n *\n * @param {String} html The original HTML pasted to the editor.\n * @returns {String} The transformed HTML that fixes the list markup to be\n *   correctly represented on an HTML document.\n */\nexport var transformMsDesktop = function transformMsDesktop(html) {\n  var _doc$querySelector2;\n  var doc = document.createElement(\"div\");\n  doc.innerHTML = removeMsMetaSegments(html);\n  var elements = doc.querySelectorAll([\".MsoListParagraph\", \".MsoListParagraphCxSpFirst\", \".MsoListParagraphCxSpMiddle\", \".MsoListParagraphCxSpLast\"].join(\", \"));\n  if (elements.length < 1) {\n    return html;\n  }\n  var listStyles = parseMsoListStyles(doc);\n  (_doc$querySelector2 = doc.querySelector(\"style\")) === null || _doc$querySelector2 === void 0 ? void 0 : _doc$querySelector2.remove();\n  var currentLevel = 1,\n    currentList = null;\n  elements.forEach(function (paragraph) {\n    var _detectMsoList = detectMsoList(paragraph),\n      msoType = _detectMsoList.type,\n      level = _detectMsoList.level;\n    var listStyle = getMsoListStyle(msoType, level, listStyles);\n    var _converMsoListStyleTo = converMsoListStyleToHtml(listStyle),\n      tag = _converMsoListStyleTo.tag,\n      type = _converMsoListStyleTo.type;\n    var li = document.createElement(\"li\");\n    var pa = document.createElement(\"p\");\n    pa.innerHTML = paragraph.innerHTML;\n    li.append(pa);\n    if (paragraph.classList.contains(\"MsoListParagraph\") || paragraph.classList.contains(\"MsoListParagraphCxSpFirst\")) {\n      currentLevel = 1;\n      currentList = document.createElement(tag);\n      if (tag === \"ol\" && type) {\n        currentList.setAttribute(\"type\", type);\n      }\n      currentList.append(li);\n      paragraph.replaceWith(currentList);\n    } else {\n      if (level > currentLevel) {\n        currentLevel += 1;\n        var subList = document.createElement(tag);\n        if (tag === \"ol\" && type) {\n          subList.setAttribute(\"type\", type);\n        }\n        if (level === currentLevel) {\n          subList.append(li);\n        } else {\n          var subLi = document.createElement(\"li\");\n          var subPa = document.createElement(\"p\");\n          subLi.append(subPa);\n          subList.append(subLi);\n        }\n        currentList.lastElementChild.append(subList);\n        currentList = subList;\n      } else {\n        while (level < currentLevel) {\n          currentLevel -= 1;\n          var candidate = currentList.parentNode.closest(\"ol, ul\");\n          if (candidate) {\n            currentList = candidate;\n          } else {\n            currentLevel = level;\n            break;\n          }\n        }\n        currentList.append(li);\n      }\n      if (paragraph.classList.contains(\"MsoListParagraphCxSpLast\")) {\n        currentLevel = 1;\n        currentList = null;\n      }\n      paragraph.remove();\n    }\n  });\n  return doc.innerHTML;\n};\n\n/**\n * Fixes issues pasting content from Office 365. Modifies the list structure\n * to represent the correct sub-list hierarchy based on the data available in\n * the HTML copied from Office 365. Based on this, Tiptap is able to correctly\n * create the hierarchy structure for the lists.\n *\n * See: https://github.com/ueberdosis/tiptap/issues/3751\n *\n * @param {String} html The original HTML pasted to the editor.\n * @returns {String} The transformed HTML that fixes the list hierarchy to be\n *   correctly represented on an HTML document.\n */\nexport var transformMsCould = function transformMsCould(html) {\n  var doc = document.createElement(\"div\");\n  doc.innerHTML = html;\n\n  // Fetch all the MS lists from the pasted content\n  var lists = {};\n  doc.querySelectorAll(\".ListContainerWrapper\").forEach(function (wrapper) {\n    var _li$dataset$listid, _lists$_li$dataset$li;\n    var li = wrapper.querySelector(\"li[data-listid]\");\n    (_lists$_li$dataset$li = lists[_li$dataset$listid = li.dataset.listid]) !== null && _lists$_li$dataset$li !== void 0 ? _lists$_li$dataset$li : lists[_li$dataset$listid] = [];\n    lists[li.dataset.listid].push({\n      wrapper: wrapper,\n      level: parseInt(li.dataset.ariaLevel, 10)\n    });\n  });\n  if (Object.keys(lists).length < 1) {\n    return html;\n  }\n\n  // Move the list elements to the correct hierarchical positions\n  Object.values(lists).forEach(function (list) {\n    var _list$shift = list.shift(),\n      parentWrapper = _list$shift.wrapper;\n    var parent = parentWrapper.querySelector(\"ol, ul\");\n    parentWrapper.replaceWith(parent);\n    var currentLevel = 1;\n    var documentCurrentLevel = 1;\n    list.forEach(function (_ref) {\n      var wrapper = _ref.wrapper,\n        level = _ref.level;\n      var listElement = wrapper.querySelector(\"ol, ul\");\n      if (level > documentCurrentLevel) {\n        var target = null;\n        while (level > documentCurrentLevel) {\n          documentCurrentLevel += 1;\n          if (parent.lastElementChild) {\n            currentLevel += 1;\n            target = parent.lastElementChild;\n          }\n        }\n        target.append(listElement);\n        parent = listElement;\n      } else {\n        var _parent;\n        while (level < currentLevel) {\n          currentLevel -= 1;\n          var candidate = parent.parentNode.closest(\"ol, ul\");\n          if (candidate) {\n            parent = candidate;\n          } else {\n            currentLevel = level;\n            break;\n          }\n        }\n        documentCurrentLevel = level;\n        (_parent = parent).append.apply(_parent, _toConsumableArray(listElement.querySelectorAll(\"li\")));\n        listElement.remove();\n      }\n      wrapper.remove();\n    });\n  });\n  return doc.innerHTML;\n};\nvar transformers = [transformMsDesktop, transformMsCould];\nexport default (function (html) {\n  var _final = html;\n  transformers.forEach(function (method) {\n    return _final = method(_final);\n  });\n  return _final;\n});","map":{"version":3,"names":["parseMsoListStyles","doc","_doc$querySelector","style","querySelector","textContent","listStyles","_toConsumableArray","matchAll","forEach","match","styleDefs","replace","split","styleDef","_styleDef$split","_styleDef$split2","_slicedToArray","key","val","detectMsoList","element","currentStyle","getAttribute","type","level","listStyleMatch","_listStyleMatch","parseInt","getMsoListStyle","typeStyle","levelStyle","concat","Object","assign","converMsoListStyleToHtml","listStyle","tag","removeMsMetaSegments","html","transformMsDesktop","_doc$querySelector2","document","createElement","innerHTML","elements","querySelectorAll","join","length","remove","currentLevel","currentList","paragraph","_detectMsoList","msoType","_converMsoListStyleTo","li","pa","append","classList","contains","setAttribute","replaceWith","subList","subLi","subPa","lastElementChild","candidate","parentNode","closest","transformMsCould","lists","wrapper","_li$dataset$listid","_lists$_li$dataset$li","dataset","listid","push","ariaLevel","keys","values","list","_list$shift","shift","parentWrapper","parent","documentCurrentLevel","_ref","listElement","target","_parent","apply","transformers","_final","method"],"sources":["/home/daniele/decidim_idra-main/app/packs/src/decidim/editor/utilities/paste_transform.js"],"sourcesContent":["const parseMsoListStyles = (doc) => {\n  const style = doc.querySelector(\"style\")?.textContent;\n  if (!style) {\n    return {};\n  }\n\n  const listStyles = {};\n  [...style.matchAll(/@list\\s+(l\\d+:level\\d+)[\\s]+\\{([^}]+)\\}/g)].forEach((match) => {\n    const styleDefs = {};\n    match[2].replace(/[\\s]+/g, \"\").split(\";\").forEach((styleDef) => {\n      const [key, val] = styleDef.split(\":\");\n      styleDefs[key] = val;\n    });\n    listStyles[match[1]] = styleDefs;\n  });\n\n  return listStyles;\n};\n\nconst detectMsoList = (element) => {\n  const currentStyle = element.getAttribute(\"style\");\n  if (!currentStyle) {\n    return { type: null, level: 1 };\n  }\n  const listStyleMatch = currentStyle.match(/mso-list:(l\\d+)\\s(level\\d+)/);\n  if (listStyleMatch) {\n    const [, type, level] = listStyleMatch;\n    return { type, level: parseInt(level.match(/\\d/), 10) };\n  }\n  return { type: null, level: 1 };\n};\n\nconst getMsoListStyle = (type, level, styleDefs) => {\n  if (type === null) {\n    return {};\n  }\n\n  const typeStyle = styleDefs[type] || {};\n  const levelStyle = styleDefs[`${type}:level${level}`] || {};\n  return Object.assign(typeStyle, levelStyle);\n};\n\nconst converMsoListStyleToHtml = (listStyle) => {\n  let tag = \"ol\",\n      type = null;\n  switch (listStyle[\"mso-level-number-format\"]) {\n  case \"bullet\":\n    tag = \"ul\";\n    break;\n  case \"alpha-lower\":\n  case \"lower-alpha\":\n    type = \"a\";\n    break;\n  case \"alpha-upper\":\n  case \"upper-alpha\":\n    type = \"A\";\n    break;\n  case \"roman-lower\":\n  case \"lower-roman\":\n    type = \"i\";\n    break;\n  case \"roman-upper\":\n  case \"upper-roman\":\n    type = \"I\";\n    break;\n  default:\n    type = \"1\";\n    break;\n  }\n\n  return { tag, type };\n};\n\nexport const removeMsMetaSegments = (html) => {\n  return html.replace(/<!\\[if\\s+[^\\]]+\\]>((?!<!\\[endif\\])[\\s\\S])+<!\\[endif\\]>/g, \"\");\n}\n\n/**\n * Fixes issues pasting content from desktop version of Word. Replaces the flat\n * lists represented with `<p>` elements with actual list hierarchy based on the\n * data available in the HTML copied from desktop Word.\n *\n * See: https://github.com/ueberdosis/tiptap/issues/3756\n *\n * @param {String} html The original HTML pasted to the editor.\n * @returns {String} The transformed HTML that fixes the list markup to be\n *   correctly represented on an HTML document.\n */\nexport const transformMsDesktop = (html) => {\n  const doc = document.createElement(\"div\");\n  doc.innerHTML = removeMsMetaSegments(html);\n\n  const elements = doc.querySelectorAll([\n    \".MsoListParagraph\",\n    \".MsoListParagraphCxSpFirst\",\n    \".MsoListParagraphCxSpMiddle\",\n    \".MsoListParagraphCxSpLast\"\n  ].join(\", \"));\n  if (elements.length < 1) {\n    return html;\n  }\n\n  const listStyles = parseMsoListStyles(doc);\n  doc.querySelector(\"style\")?.remove();\n\n  let currentLevel = 1,\n      currentList = null;\n  elements.forEach((paragraph) => {\n    const { type: msoType, level } = detectMsoList(paragraph);\n    const listStyle = getMsoListStyle(msoType, level, listStyles);\n    const { tag, type } = converMsoListStyleToHtml(listStyle);\n\n    const li = document.createElement(\"li\");\n    const pa = document.createElement(\"p\");\n    pa.innerHTML = paragraph.innerHTML;\n    li.append(pa);\n\n    if (paragraph.classList.contains(\"MsoListParagraph\") || paragraph.classList.contains(\"MsoListParagraphCxSpFirst\")) {\n      currentLevel = 1;\n      currentList = document.createElement(tag);\n      if (tag === \"ol\" && type) {\n        currentList.setAttribute(\"type\", type);\n      }\n\n      currentList.append(li);\n      paragraph.replaceWith(currentList);\n    } else {\n      if (level > currentLevel) {\n        currentLevel += 1;\n\n        const subList = document.createElement(tag);\n        if (tag === \"ol\" && type) {\n          subList.setAttribute(\"type\", type);\n        }\n        if (level === currentLevel) {\n          subList.append(li);\n        } else {\n          const subLi = document.createElement(\"li\");\n          const subPa = document.createElement(\"p\");\n          subLi.append(subPa);\n          subList.append(subLi);\n        }\n        currentList.lastElementChild.append(subList);\n        currentList = subList;\n      } else {\n        while (level < currentLevel) {\n          currentLevel -= 1;\n          const candidate = currentList.parentNode.closest(\"ol, ul\");\n          if (candidate) {\n            currentList = candidate;\n          } else {\n            currentLevel = level;\n            break;\n          }\n        }\n        currentList.append(li);\n      }\n\n      if (paragraph.classList.contains(\"MsoListParagraphCxSpLast\")) {\n        currentLevel = 1;\n        currentList = null;\n      }\n\n      paragraph.remove();\n    }\n  });\n\n  return doc.innerHTML;\n}\n\n/**\n * Fixes issues pasting content from Office 365. Modifies the list structure\n * to represent the correct sub-list hierarchy based on the data available in\n * the HTML copied from Office 365. Based on this, Tiptap is able to correctly\n * create the hierarchy structure for the lists.\n *\n * See: https://github.com/ueberdosis/tiptap/issues/3751\n *\n * @param {String} html The original HTML pasted to the editor.\n * @returns {String} The transformed HTML that fixes the list hierarchy to be\n *   correctly represented on an HTML document.\n */\nexport const transformMsCould = (html) => {\n  const doc = document.createElement(\"div\");\n  doc.innerHTML = html;\n\n  // Fetch all the MS lists from the pasted content\n  const lists = {};\n  doc.querySelectorAll(\".ListContainerWrapper\").forEach((wrapper) => {\n    const li = wrapper.querySelector(\"li[data-listid]\");\n    lists[li.dataset.listid] ??= [];\n    lists[li.dataset.listid].push({ wrapper, level: parseInt(li.dataset.ariaLevel, 10) });\n  });\n  if (Object.keys(lists).length < 1) {\n    return html;\n  }\n\n  // Move the list elements to the correct hierarchical positions\n  Object.values(lists).forEach((list) => {\n    const { wrapper: parentWrapper } = list.shift();\n\n    let parent = parentWrapper.querySelector(\"ol, ul\");\n    parentWrapper.replaceWith(parent);\n\n    let currentLevel = 1;\n    let documentCurrentLevel = 1;\n    list.forEach(({ wrapper, level }) => {\n      const listElement = wrapper.querySelector(\"ol, ul\");\n\n      if (level > documentCurrentLevel) {\n        let target = null;\n        while (level > documentCurrentLevel) {\n          documentCurrentLevel += 1;\n          if (parent.lastElementChild) {\n            currentLevel += 1;\n            target = parent.lastElementChild;\n          }\n        }\n\n        target.append(listElement);\n        parent = listElement;\n      } else {\n        while (level < currentLevel) {\n          currentLevel -= 1;\n          const candidate = parent.parentNode.closest(\"ol, ul\");\n          if (candidate) {\n            parent = candidate;\n          } else {\n            currentLevel = level;\n            break;\n          }\n        }\n        documentCurrentLevel = level;\n        parent.append(...listElement.querySelectorAll(\"li\"));\n        listElement.remove();\n      }\n\n      wrapper.remove();\n    });\n  });\n\n  return doc.innerHTML;\n};\n\nconst transformers = [transformMsDesktop, transformMsCould];\n\nexport default (html) => {\n  let final = html;\n  transformers.forEach((method) => (final = method(final)));\n  return final;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
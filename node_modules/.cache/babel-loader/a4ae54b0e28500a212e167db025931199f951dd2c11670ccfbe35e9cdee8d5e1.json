{"ast":null,"code":"function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\n/* eslint-disable require-jsdoc */\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\";\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\";\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\";\nimport HistoryOverride from \"src/decidim/editor/history_override\";\n\n// Disable warning messages from overwritting modules\nQuill.debug(\"error\");\n\n// It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\nvar Delta = Quill[\"import\"](\"delta\");\nvar Break = Quill[\"import\"](\"blots/break\");\nvar Embed = Quill[\"import\"](\"blots/embed\");\nvar Scroll = Quill[\"import\"](\"blots/scroll\");\nvar Parchment = Quill[\"import\"](\"parchment\");\nQuill.register({\n  \"modules/history\": HistoryOverride\n}, true);\nvar icons = Quill[\"import\"](\"ui/icons\");\nicons.linebreak = \"⏎\";\nvar SmartBreak = /*#__PURE__*/function (_Break) {\n  function SmartBreak() {\n    _classCallCheck(this, SmartBreak);\n    return _callSuper(this, SmartBreak, arguments);\n  }\n  _inherits(SmartBreak, _Break);\n  return _createClass(SmartBreak, [{\n    key: \"length\",\n    value: function length() {\n      return 1;\n    }\n  }, {\n    key: \"value\",\n    value: function value() {\n      return \"\\n\";\n    }\n  }, {\n    key: \"insertInto\",\n    value: function insertInto(parent, ref) {\n      // Embed.prototype.insertInto.call(this, parent, ref);\n      Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n    }\n  }]);\n}(Break);\nQuill.register(SmartBreak);\n\n// Override quill/blots/scroll.js\nvar ScrollOvderride = /*#__PURE__*/function (_Scroll) {\n  function ScrollOvderride() {\n    _classCallCheck(this, ScrollOvderride);\n    return _callSuper(this, ScrollOvderride, arguments);\n  }\n  _inherits(ScrollOvderride, _Scroll);\n  return _createClass(ScrollOvderride, [{\n    key: \"optimize\",\n    value: function optimize() {\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.batch === true) {\n        return;\n      }\n      this.parchmentOptimize(mutations, context);\n      if (mutations.length > 0) {\n        // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n        this.emitter.emit(\"scroll-optimize\", mutations, context);\n      }\n    }\n\n    // Override parchment/src/blot/scroll.ts\n  }, {\n    key: \"parchmentOptimize\",\n    value: function parchmentOptimize() {\n      var _this = this;\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // super.optimize(context);\n      Reflect.apply(Parchment.Container.prototype.optimize, this, [context]);\n\n      // We must modify mutations directly, cannot make copy and then modify\n      // let records = [].slice.call(this.observer.takeRecords());\n      var records = _toConsumableArray(this.observer.takeRecords());\n      // Array.push currently seems to be implemented by a non-tail recursive function\n      // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n      var mark = function mark(blot, markParent) {\n        if (!blot || blot === _this) {\n          return;\n        }\n        if (!blot.domNode.parentNode) {\n          return;\n        }\n        if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n          blot.domNode.__blot.mutations = [];\n        }\n        if (markParent) {\n          mark(blot.parent);\n        }\n      };\n      var optimize = function optimize(blot) {\n        // Post-order traversal\n        if (!blot.domNode.__blot) {\n          return;\n        }\n        if (blot instanceof Parchment.Container) {\n          blot.children.forEach(optimize);\n        }\n        blot.optimize(context);\n      };\n      var remaining = mutations;\n      for (var ind = 0; remaining.length > 0; ind += 1) {\n        // MAX_OPTIMIZE_ITERATIONS = 100\n        if (ind >= 100) {\n          throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n        }\n        remaining.forEach(function (mutation) {\n          var blot = Parchment.find(mutation.target, true);\n          if (!blot) {\n            return;\n          }\n          if (blot.domNode === mutation.target) {\n            if (mutation.type === \"childList\") {\n              mark(Parchment.find(mutation.previousSibling, false));\n              mutation.addedNodes.forEach(function (node) {\n                var child = Parchment.find(node, false);\n                mark(child, false);\n                if (child instanceof Parchment.Container) {\n                  child.children.forEach(function (grandChild) {\n                    mark(grandChild, false);\n                  });\n                }\n              });\n            } else if (mutation.type === \"attributes\") {\n              mark(blot.prev);\n            }\n          }\n          mark(blot);\n        });\n        this.children.forEach(optimize);\n        remaining = _toConsumableArray(this.observer.takeRecords());\n        records = remaining.slice();\n        while (records.length > 0) {\n          mutations.push(records.pop());\n        }\n      }\n    }\n  }]);\n}(Scroll);\n;\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\nexport default function lineBreakButtonHandler(quill) {\n  var range = quill.selection.getRange()[0];\n  var currentLeaf = quill.getLeaf(range.index)[0];\n  var nextLeaf = quill.getLeaf(range.index + 1)[0];\n  var previousChar = quill.getText(range.index - 1, 1);\n\n  // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n  if (nextLeaf === null || currentLeaf.parent !== nextLeaf.parent) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    var delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  // Now that we've inserted a line break, move the cursor forward\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\nQuill.register(\"modules/linebreak\", function (quill) {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", function () {\n    lineBreakButtonHandler(quill);\n  });\n  quill.emitter.on(\"editor-ready\", function () {\n    var length = quill.getLength();\n    var text = quill.getText(length - 2, 2);\n\n    // Remove extraneous new lines\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n  return;\n});","map":{"version":3,"names":["addEnterBindings","backspaceBindingsRangeAny","backspaceBindings","HistoryOverride","Quill","debug","Delta","Break","Embed","Scroll","Parchment","register","icons","linebreak","SmartBreak","_Break","_classCallCheck","_callSuper","arguments","_inherits","_createClass","key","value","length","insertInto","parent","ref","Reflect","apply","prototype","ScrollOvderride","_Scroll","optimize","mutations","undefined","context","batch","parchmentOptimize","emitter","emit","_this","Container","records","_toConsumableArray","observer","takeRecords","push","pop","mark","blot","markParent","domNode","parentNode","__blot","children","forEach","remaining","ind","Error","mutation","find","target","type","previousSibling","addedNodes","node","child","grandChild","prev","slice","lineBreakButtonHandler","quill","range","selection","getRange","currentLeaf","getLeaf","index","nextLeaf","previousChar","getText","insertEmbed","delta","retain","insert","updateContents","sources","USER","setSelection","SILENT","getModule","addHandler","on","getLength","text","deleteText"],"sources":["/home/daniele/decidim_idra/app/packs/src/decidim/editor/linebreak_module.js"],"sourcesContent":["/* eslint-disable require-jsdoc */\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\"\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\"\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\"\nimport HistoryOverride from \"src/decidim/editor/history_override\"\n\n// Disable warning messages from overwritting modules\nQuill.debug(\"error\");\n\n// It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\nconst Delta = Quill.import(\"delta\");\nconst Break = Quill.import(\"blots/break\");\nconst Embed = Quill.import(\"blots/embed\");\nconst Scroll = Quill.import(\"blots/scroll\");\nconst Parchment = Quill.import(\"parchment\");\nQuill.register({\"modules/history\": HistoryOverride}, true);\nlet icons = Quill.import(\"ui/icons\");\nicons.linebreak = \"⏎\";\n\nclass SmartBreak extends Break {\n  length() {\n    return 1;\n  }\n\n  value() {\n    return \"\\n\";\n  }\n\n  insertInto(parent, ref) {\n    // Embed.prototype.insertInto.call(this, parent, ref);\n    Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n  }\n}\nQuill.register(SmartBreak);\n\n// Override quill/blots/scroll.js\nclass ScrollOvderride extends Scroll {\n  optimize(mutations = [], context = {}) {\n    if (this.batch === true) {\n      return;\n    }\n\n    this.parchmentOptimize(mutations, context);\n\n    if (mutations.length > 0) {\n      // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n      this.emitter.emit(\"scroll-optimize\", mutations, context);\n    }\n  }\n\n  // Override parchment/src/blot/scroll.ts\n  parchmentOptimize(mutations = [], context = {}) {\n    // super.optimize(context);\n    Reflect.apply(Parchment.Container.prototype.optimize, this, [context]);\n\n    // We must modify mutations directly, cannot make copy and then modify\n    // let records = [].slice.call(this.observer.takeRecords());\n    let records = [...this.observer.takeRecords()];\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    let mark = (blot, markParent) => {\n      if (!blot || blot === this) {\n        return;\n      }\n      if (!blot.domNode.parentNode) {\n        return;\n      }\n      if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n        blot.domNode.__blot.mutations = [];\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    let optimize = (blot) => {\n      // Post-order traversal\n      if (!blot.domNode.__blot) {\n        return;\n      }\n\n      if (blot instanceof Parchment.Container) {\n        blot.children.forEach(optimize);\n      }\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let ind = 0; remaining.length > 0; ind += 1) {\n      // MAX_OPTIMIZE_ITERATIONS = 100\n      if (ind >= 100) {\n        throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n      }\n      remaining.forEach((mutation) => {\n        let blot = Parchment.find(mutation.target, true);\n        if (!blot) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === \"childList\") {\n            mark(Parchment.find(mutation.previousSibling, false));\n\n            mutation.addedNodes.forEach((node) => {\n              let child = Parchment.find(node, false);\n              mark(child, false);\n              if (child instanceof Parchment.Container) {\n                child.children.forEach(function(grandChild) {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === \"attributes\") {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = [...this.observer.takeRecords()];\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n};\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\n\nexport default function lineBreakButtonHandler(quill) {\n  let range = quill.selection.getRange()[0];\n  let currentLeaf = quill.getLeaf(range.index)[0];\n  let nextLeaf = quill.getLeaf(range.index + 1)[0];\n  const previousChar = quill.getText(range.index - 1, 1);\n\n  // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n  if (nextLeaf === null || (currentLeaf.parent !== nextLeaf.parent)) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    const delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  // Now that we've inserted a line break, move the cursor forward\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\n\nQuill.register(\"modules/linebreak\", (quill) => {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", () => {\n    lineBreakButtonHandler(quill);\n  });\n\n  quill.emitter.on(\"editor-ready\", () => {\n    const length = quill.getLength();\n    const text = quill.getText(length - 2, 2);\n\n    // Remove extraneous new lines\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n\n  return;\n});\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}